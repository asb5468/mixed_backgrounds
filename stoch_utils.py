import numpy as np
import lal
import pdb
import bilby

def generate_stoch_signal(sampling_frequency, duration, Sh_true):
    '''Calculates h(f) colored by cross power spectral density Sh_true'''
    white_noise, frequency = bilby.core.utils.create_white_noise(sampling_frequency, duration)
    stoch_h = Sh_true**0.5 * white_noise
    return stoch_h

def Sh(fseries, logOmega, alpha, **kwargs):
    '''Calculates the signal cross power spectral density from Omega_gw'''
    Mpc_in_km = 3.086e+19
    #H0 = 68. / Mpc_in_km
    H0 = 3.240779289444365023237687716352957261e-18
    Omega = 10**logOmega

    S_h =  (3*H0**2./(10*np.pi**2.)) * (Omega  / (fseries**3.)) * (fseries/25.)**alpha
    S_h = np.nan_to_num(S_h)
    return S_h

def Sh0(fseries, **kwargs):
    return 0*fseries

def time_delay_geocentric(detector1, detector2, theta, phi):
    """
    Calculate time delay between two detectors in geocentric coordinates based on XLALArrivaTimeDiff in TimeDelay.c
    Input:
    detector1 - cartesian coordinate vector for the first detector in the geocentric frame
                generated by the Interferometer class as self.vertex
    detector2 - cartesian coordinate vector for the second detector in the geocentric frame
    To get time delay from Earth center, use detector2 = np.array([0,0,0])
    theta, phi

    Output:
    delta_t - time delay between the two detectors in the geocentric frame
    """
    omega = np.array([np.sin(theta) * np.cos(phi), np.sin(theta) * np.sin(phi), np.cos(theta)])
    delta_d = detector2 - detector1
    delta_t = np.dot(omega, delta_d) / utils.speed_of_light
    return delta_t


def get_polarization_tensor(theta, phi, psi, mode):
    """
    Calculate the polarization tensor for a given sky location and time

    See Nishizawa et al. (2009) arXiv:0903.0528 for definitions of the polarisation tensors.
    [u, v, w] represent the Earth-frame
    [m, n, omega] represent the wave-frame
    Note: there is a typo in the definition of the wave-frame in Nishizawa et al.

    :param ra: right ascension in radians
    :param dec: declination in radians
    :param time: geocentric GPS time
    :param psi: binary polarisation angle counter-clockwise about the direction of propagation
    :param mode: polarisation mode
    :return: polarization_tensor(ra, dec, time, psi, mode): polarization tensor for the specified mode.
    """
    u = np.array([np.cos(phi) * np.cos(theta), np.cos(theta) * np.sin(phi), -np.sin(theta)])
    v = np.array([-np.sin(phi), np.cos(phi), 0])
    m = -u * np.sin(psi) - v * np.cos(psi)
    n = -u * np.cos(psi) + v * np.sin(psi)

    if mode.lower() == 'plus':
        return np.einsum('i,j->ij', m, m) - np.einsum('i,j->ij', n, n)
    elif mode.lower() == 'cross':
        return np.einsum('i,j->ij', m, n) + np.einsum('i,j->ij', n, m)
    elif mode.lower() == 'breathing':
        return np.einsum('i,j->ij', m, m) + np.einsum('i,j->ij', n, n)

    omega = np.cross(m, n)
    if mode.lower() == 'longitudinal':
        return np.sqrt(2) * np.einsum('i,j->ij', omega, omega)
    elif mode.lower() == 'x':
        return np.einsum('i,j->ij', m, omega) + np.einsum('i,j->ij', omega, m)
    elif mode.lower() == 'y':
        return np.einsum('i,j->ij', n, omega) + np.einsum('i,j->ij', omega, n)
    else:
        logging.warning("{} not a polarization mode!".format(mode))
        return None

def antenna_response(detector_tensor, polarization_tensor):
    detector_response = np.einsum('ij,ij->', detector_tensor, polarization_tensor)
    return detector_response

def get_stoch_signal_in_detector_pair(sampling_frequency, duration, Sh_true, detector1, detector2):
    '''This function does not work. Deprecated in favor of the one below.'''
    h1 = 0
    h2 = 0
    for theta in np.linspace(0,np.pi,180):
        print(np.degrees(theta))
        for phi in np.linspace(0,2*np.pi,360):
            hf_true = generate_stoch_signal(sampling_frequency, duration, Sh_true)
            polarization_tensor = get_polarization_tensor(theta, phi, np.pi/8, 'plus')
            if theta>0:
                pdb.set_trace()
            dt1 = time_delay_geocentric(detector1.vertex,np.array([0,0,0]),theta, phi)
            dt2 = time_delay_geocentric(detector2.vertex,np.array([0,0,0]),theta, phi)
            int1 = hf_true*np.exp(-2*np.pi*1j*detector1.frequency_array*dt1)*antenna_response(detector1.detector_tensor, polarization_tensor)*np.sin(theta)
            int2 = hf_true*np.exp(-2*np.pi*1j*detector2.frequency_array*dt2)*antenna_response(detector2.detector_tensor, polarization_tensor)*np.sin(theta)
            h1 += int1*np.radians(1)**2
            h2 += int2*np.radians(1)**2
    return h1, h2

def create_orf_convolution_signal(orf, sampling_frequency, time_duration, Sh_true):
    '''
    Creates a correlated signal including the correct 
    contributions from the overlap reduction function, but
    only for one detector pair.
    '''
    z1 = generate_stoch_signal(sampling_frequency, time_duration, Sh_true)
    z2 = generate_stoch_signal(sampling_frequency, time_duration, Sh_true)
    s = np.sqrt(1-orf**2)
    a = np.sqrt((1+s)/2)
    b = orf/np.sqrt(2*(1+s))
    h1 = (a*z1 + b*z2)
    h2 = (b*z1 + a*z2)
    return h1, h2

def SNR(Sh_true, orf, PSD, time, df):
    '''
    Calculate the standard stochastic SNR, Eq 3.72 from 
    https://arxiv.org/abs/gr-qc/9710117
    '''
    SNR2 = 2*time*df*np.sum((orf*Sh_true/PSD)**2)
    return np.sqrt(SNR2)
